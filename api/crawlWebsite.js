const puppeteer = require('puppeteer');
const { JSDOM } = require('jsdom');


class WebScraper {
    constructor(startUrl, maxDepth = 2) {
        this.startUrl = startUrl;
        this.maxDepth = maxDepth;
        this.browser = null;
        this.page = null;
        this.visitedUrls = new Set();
        // TODO add more stuff
        this.ready = false;
    }
    async init() {
        this.browser = await puppeteer.launch();
        this.page = await this.browser.newPage();
        this.ready = true;
    }
    async getPageContent(pageUrl) {
        if (!this.ready) {
            await this.init();
        }
        await this.page.goto(pageUrl);
        const content = await this.page.content();
        return content;
    }
    // AI: this function was generated by AI
    async getCleanHtmlContent(pageUrl, keepAttributes = []) {
        const content = await this.getPageContent(pageUrl);
        const dom = new JSDOM(content);
        const { document, Node } = dom.window; // Define Node for easier reference
        
        function cleanNode(node) {
            // If it's a text node, return its text content
            if (node.nodeType === Node.TEXT_NODE) {
                return node.textContent.trim();
            }
            
            // If it's an element node
            if (node.nodeType === Node.ELEMENT_NODE) {
                // Create a new element with just the tag name
                const cleanElement = document.createElement(node.tagName.toLowerCase());
                
                // Add back only the specified attributes
                for (const attr of keepAttributes) {
                    if (node.hasAttribute(attr)) {
                        cleanElement.setAttribute(attr, node.getAttribute(attr));
                    }
                }
                
                // Recursively clean child nodes
                for (const childNode of node.childNodes) {
                    const cleanedChild = cleanNode(childNode);
                    if (cleanedChild) {
                        if (typeof cleanedChild === 'string') {
                            cleanElement.appendChild(document.createTextNode(cleanedChild));
                        } else {
                            cleanElement.appendChild(cleanedChild);
                        }
                    }
                }
                
                return cleanElement;
            }
            
            // Ignore other types of nodes
            return null;
        }
        
        // Clean the body
        const cleanBody = cleanNode(dom.window.document.body);
        
        // Return the inner HTML of the cleaned body
        return cleanBody.innerHTML;
    }

}



(async () => {
    const scraper = new WebScraper('https://example.com');
    await scraper.init();
    // const content = await scraper.getPageContent('https://example.com');
    // console.log(content);
    const textContent = await scraper.getCleanHtmlContent('https://example.com', [ 'href' ]);
    console.log(textContent);
})();